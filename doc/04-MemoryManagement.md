# 内存管理

接下来我们开始学习C++的内存管理。
我们在`03指针传参`的部分有学习到，程序在运行的时候，内核会首先分配给程序一段连续的虚拟地址空间并做好虚拟地址与物理地址的映射页表。
那么这段虚拟地址空间中数据和代码是如何放置的呢？当然肯定不会是随机分布的。

### 内存模型与生命周期
程序运行时会分为5个区域：代码区、全局/静态区、常量区、栈区、堆区。分别讲讲这五个区域的内容和生命周期。
[作用域指变量在程序中能看见的范围，生命周期指变量在内存中存放的时间]

**代码区**中存放着函数的机器指令，生命周期持续程序运行全程，通常只读，防止被修改。
**全局/静态区**存放着全局变量和静态变量，生命周期持续程序运行全程，初始化一次，直到程序结束。
**常量区**存放着常量字符串、const全局变量，生命周期持续程序运行全程，不可修改（只读内存）。
**堆区**存放着动态分配的内存(`new/malloc`)，生命周期通过手动控制，必须手动释放，否则内存泄漏。
**栈区**存放着函数的局部变量、参数，生命周期随函数调用而变化，自动创建并自动销毁。

我们可以通过程序看看内存的分布状态：

```
int g = 10;          // 全局区
const char* msg = "Hello"; // 常量区

void func() {   // 内存分布演示
    int a = 5;        // 栈区
    int* p = new int(20); // 堆区
    static int s = 30;    // 静态区

    cout << "局部变量a地址: " << &a << endl;
    cout << "堆变量*p地址: " << p << endl;
    cout << "静态变量s地址: " << &s << endl;
    cout << "全局变量g地址: " << &g << endl;
    cout << "字符串msg地址: " << (void*)msg << endl;
    delete p;
}
```

<img width="480" height="97" alt="image" src="https://github.com/user-attachments/assets/1860231d-4f5b-4386-983c-2a4e363fbc76" />

通过结果可以看出来，栈区地址比堆区地址高，通常在高地址。

我们刚刚说到不同的内存区域有不同的生命周期，什么是生命周期呢？生命周期是指变量在内存中存在的时间。也比较好理解，我们用代码示例：

```
void test() {   // 内存分布演示
    static int count = 0; // 作用域仅在 test() 内，但生命周期贯穿整个程序
    int local = 0;        // 作用域与生命周期都仅在 test()
    count++;
    local++;
    cout << "count=" << count << ", local=" << local << endl;
}

int main() {
    //func();
    for (int i = 0; i < 3; i++) test();
    return 0;
}
```

运行后发现虽然`count`是在`test`函数中定义的，但是它的值却没有随着函数的结束而销毁。
也就是说静态变量定义后和栈区的变量不同在于，栈区变量的作用域在test函数中，而静态变量可以作用在全局中。

在虚拟地址空间中，内存从低地址到高地址依次是：

```
高地址
│
│   ┌──────────────┐
│   │ 栈区 (Stack) │ ← 局部变量、函数参数
│   ├──────────────┤
│   │ 堆区 (Heap)  │ ← 动态分配内存 (new/malloc)
│   ├──────────────┤
│   │ 全局/静态区 (Data/BSS) │ ← 全局变量、静态变量
│   ├──────────────┤
│   │ 常量区 (RO Data) │ ← 字符串常量、const数据
│   ├──────────────┤
│   │ 代码区 (Text) │ ← 函数机器指令
│   └──────────────┘
│
低地址
```

我们看看不同内存区中变量的生命周期：

```
struct Demo {
    string name;
    Demo(string n) : name(n) { cout << name << " 构造\n"; }
    ~Demo() { cout << name << " 析构\n"; }
};

Demo h("全局变量");

void func2() {
    Demo local("局部变量");
    static Demo s("静态变量");
    Demo* heap = new Demo("堆变量");
    delete heap;
}
```

<img width="469" height="174" alt="image" src="https://github.com/user-attachments/assets/1c1e1fbb-a766-4f2f-8f70-4597f87222ad" />

可以看到，栈区的变量在函数结束之后就会销毁，堆区的变量在我们delect之后销毁，而静态变量和全局变量在main函数结束后才会销毁。

### 动态内存管理

C++有三种内存分配方式，静态分配、栈分配和动态分配。当我们在运行时才知道需要用到多少内存时，就要使用动态内存:

```
int n;
std::cin >> n;
int* arr = new int[n];
```

这里n只有在运行时才知道是多少。在C++中使用new和delete分配和释放内存，这与C语言中的malloc和free的区别是什么？

对于基础变量类型来说，他们没有区别，都是用于分配内存和释放内存。但当用于类的时候，new和delete可以进行构造函数和析构函数。
这一部分我们放到后面学习类的时候再讲~

对于基本变量类型，使用new和delete可以分配和释放内存；对于数组可以使用new[]和delete[]，注意如果使用new[]分配内存，就必须要用delete[]释放内存。

使用new分配一块内存后，返回值是一个指针，指向内存中的堆区。所以我们在使用`int* p = new int(10)`时，实际上是指定义了一个指针p，
这个指针变量在栈区，作用于对应函数中，而这个指针变量存储的指针指向堆区。

相比于malloc而言，new会返回带类型的指针，而malloc只是返回一个不带类型的指针。

我们用一个程序验证一下，我们可以打印出p的地址、p指向的值和p指向的堆区存储的值：

```
void func4() {
    int* p = new int(10);

    cout << "p 的地址（在栈上）: " << &p << endl;
    cout << "p 指向的地址（在堆上）: " << p << endl;
    cout << "堆中存的值: " << *p << endl;

    delete p; // 释放单个整数
}
```

<img width="480" height="69" alt="image" src="https://github.com/user-attachments/assets/974f92d5-7152-47d8-b658-61d2c65dfc21" />

这里要注意，`delete p`只是释放了p指向的堆中的内存，而没有改变p的指向，也就是说p会变成一个野指针。

如果你new了一个内存却没有释放，这段内存就会永远留着。

比如说你在堆中申请了3块内存，其中分配情况如下：

```
堆区（Heap）：
┌──────────────┬──────────────┬──────────────┐
│   [1]        │   [2]        │   [3]        │
└──────────────┴──────────────┴──────────────┘
 ^              ^              ^
 a              b              c
```

如果不释放着三块内存，还丢失了a、b、c对应的指针，那么这段内存就永远找不回来了。
程序在运行的时候就会认为这段内存存着东西，耗费内存的资源。
所以我们需要记得释放内存`delete`

在现代C++中，推荐使用 std::unique_ptr 或 std::shared_ptr 来自动管理堆内存，避免手动 delete 导致的内存泄漏。
