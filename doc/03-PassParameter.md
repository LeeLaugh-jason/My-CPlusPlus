# 引用与传参方式

传参就是在调用一个函数的时候，将括号内的数传递给函数内部的变量的过程。参数分为两类，实参和形参，一个是调用函数传递的值，另一个是函数内部对应的的变量。

```
void sayHi(int x) {     // ← 这里的 x 是「形参」
    std::cout << "x = " << x << std::endl;
}

int main() {
    int a = 10;
    sayHi(a);           // ← 这里的 a 是「实参」
}
```

我们可以用参数+函数的方式进行一系列封装好可复用的功能~

参数传递有三种方式：值传递、引用传递、指针传递，每种传递方式对应的编译器行为也不同。

#### 值传递

最上面给出的代码就是值传递的一个实例，在我们传递参数的过程中具体发生了什么呢？

首先，我们知道C++程序运行时，内存被分为：代码区、全局区/静态区、堆区、栈区。其中栈区用来存放函数的局部变量、参数、返回地址等。

首先，我们在程序中定义了整形a变量，这个变量会被存放在栈区中main函数对应的空间（栈帧），
接着我们调用sayHi函数时，在栈区中开辟了sayHi函数的栈帧，同时也创建了函数需要的x变量的空间。

编译器将a的值复制一份传递给x，当函数进行完任务后，会将栈区中对应函数的内存释放掉，x的值也会释放。

调用逻辑如下图：

程序刚进入main时：

```
内存高地址
│
│
│  ┌────────────┐
│  │ main 栈帧  │
│  │ a = 10     │
│  └────────────┘
│
│  （还没有调用 f）
│
└──────────────────→ 低地址
```

调用`f(a)`时：

```
内存高地址
│
│  ┌────────────┐
│  │ f 栈帧     │
│  │ x = 10     │ ← 形参副本
│  │ y = 11     │ ← 局部变量
│  └────────────┘
│  ┌────────────┐
│  │ main 栈帧  │
│  │ a = 10     │
│  └────────────┘
│
└──────────────────→ 低地址
```

`f`函数结束后：

```
内存高地址
│
│  （f 栈帧销毁了）
│
│  ┌────────────┐
│  │ main 栈帧  │
│  │ a = 10     │
│  └────────────┘
│
└──────────────────→ 低地址
```

#### 引用传递

首先我们要了解，什么是引用？

引用在C++中不是一个新的变量，而是某个变量的别名。也就是说：

```
int& x = a;
```

其中x和a表示同一块内存。

那么引用传递的意思，其实就是将变量的别名传入函数中：

```
void f(int& x) {   // ← 形参是“引用”
    x = 100;
}

int main() {
    int a = 10;
    f(a);
    std::cout << a << std::endl;  // 输出 100
}
```

这段代码输出的结果是`100`，也就是说我们可以通过别名，修改变量原本的值的大小。因为本身别名和变量对应的都是同一段内存。

从底层的角度来说，x和a的地址相同：

```
int main() {
    int a = 10;
    int& x = a;   
    
    std::cout << &a << std::endl; // 地址①
    std::cout << &x << std::endl; // 地址②
    return 0;
}
```

<img width="455" height="47" alt="image" src="https://github.com/user-attachments/assets/ee59c21f-3c93-46f3-9f61-cbd74c8e4293" />

也就是说其实编译器遇到x这个别名时，会把将x看作a，记录下x引用的是a的地址。x本身没有独立空间。

#### 指针传递

什么是指针传递？就是在调用函数的时候，将变量的地址传递给函数参数，让函数通过这个地址间接访问或者修改原变量。

```
void f(int* p) {
    *p = 100;  // 修改 p 指向的那块内存
}

int main() {
    int a = 10;
    f(&a);  // 把 a 的地址传过去
    std::cout << a << std::endl; // 输出 100
}
```

也就是在调用f函数后，其栈帧对应存放的是a的地址，执行任务会通过地址间接修改a变量的值。

那它相比于引用有什么区别吗？有的：指针传递可以传递空值

```
#include <iostream>

void reset(int* p) {
    if (p != nullptr) {
        *p = 0;
    }
}

int main(){
    int a = 5;
    reset(&a);    // 改成 0
    std::cout << "a = " << a << std::endl;
    reset(nullptr); // 不操作
    return 0;
}
```

<img width="448" height="36" alt="image" src="https://github.com/user-attachments/assets/d36abcea-e79d-49cf-bfe5-1925ffb61a14" />

什么是空值？这不应该传递一个指针吗？

是的，其实这个‘空值’就是一个特殊的指针，不过它不指向任何有效对象。

啥是有效对象？难道这个指针指向的地址全是000的空白地址吗？

简单来说，空指针不指向任何一块真实存在的内存区域，它只是一个特殊的地址值，保证永远不会与任何有效对象的地址相同。
