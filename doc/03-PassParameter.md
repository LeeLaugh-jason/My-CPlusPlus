# 引用与传参方式

传参就是在调用一个函数的时候，将括号内的数传递给函数内部的变量的过程。参数分为两类，实参和形参，一个是调用函数传递的值，另一个是函数内部对应的的变量。

```
void sayHi(int x) {     // ← 这里的 x 是「形参」
    std::cout << "x = " << x << std::endl;
}

int main() {
    int a = 10;
    sayHi(a);           // ← 这里的 a 是「实参」
}
```

我们可以用参数+函数的方式进行一系列封装好可复用的功能~

参数传递有三种方式：值传递、引用传递、指针传递，每种传递方式对应的编译器行为也不同。

#### 值传递

最上面给出的代码就是值传递的一个实例，在我们传递参数的过程中具体发生了什么呢？

首先，我们知道C++程序运行时，内存被分为：代码区、全局区/静态区、堆区、栈区。其中栈区用来存放函数的局部变量、参数、返回地址等。

首先，我们在程序中定义了整形a变量，这个变量会被存放在栈区中main函数对应的空间（栈帧），
接着我们调用sayHi函数时，在栈区中开辟了sayHi函数的栈帧，同时也创建了函数需要的x变量的空间。

编译器将a的值复制一份传递给x，当函数进行完任务后，会将栈区中对应函数的内存释放掉，x的值也会释放。

调用逻辑如下图：

程序刚进入main时：

```
内存高地址
│
│
│  ┌────────────┐
│  │ main 栈帧  │
│  │ a = 10     │
│  └────────────┘
│
│  （还没有调用 f）
│
└──────────────────→ 低地址
```

调用`f(a)`时：

```
内存高地址
│
│  ┌────────────┐
│  │ f 栈帧     │
│  │ x = 10     │ ← 形参副本
│  │ y = 11     │ ← 局部变量
│  └────────────┘
│  ┌────────────┐
│  │ main 栈帧  │
│  │ a = 10     │
│  └────────────┘
│
└──────────────────→ 低地址
```

`f`函数结束后：

```
内存高地址
│
│  （f 栈帧销毁了）
│
│  ┌────────────┐
│  │ main 栈帧  │
│  │ a = 10     │
│  └────────────┘
│
└──────────────────→ 低地址
```

#### 引用传递

首先我们要了解，什么是引用？

引用在C++中不是一个新的变量，而是某个变量的别名。也就是说：

```
int& x = a;
```

其中x和a表示同一块内存。

那么引用传递的意思，其实就是将变量的别名传入函数中：

```
void f(int& x) {   // ← 形参是“引用”
    x = 100;
}

int main() {
    int a = 10;
    f(a);
    std::cout << a << std::endl;  // 输出 100
}
```

这段代码输出的结果是`100`，也就是说我们可以通过别名，修改变量原本的值的大小。因为本身别名和变量对应的都是同一段内存。

从底层的角度来说，x和a的地址相同：

```
int main() {
    int a = 10;
    int& x = a;   
    
    std::cout << &a << std::endl; // 地址①
    std::cout << &x << std::endl; // 地址②
    return 0;
}
```

<img width="455" height="47" alt="image" src="https://github.com/user-attachments/assets/ee59c21f-3c93-46f3-9f61-cbd74c8e4293" />

也就是说其实编译器遇到x这个别名时，会把将x看作a，记录下x引用的是a的地址。x本身没有独立空间。

#### 指针传递

什么是指针传递？就是在调用函数的时候，将变量的地址传递给函数参数，让函数通过这个地址间接访问或者修改原变量。

```
void f(int* p) {
    *p = 100;  // 修改 p 指向的那块内存
}

int main() {
    int a = 10;
    f(&a);  // 把 a 的地址传过去
    std::cout << a << std::endl; // 输出 100
}
```

也就是在调用f函数后，其栈帧对应存放的是a的地址，执行任务会通过地址间接修改a变量的值。

那它相比于引用有什么区别吗？有的：指针传递可以传递空值

```
#include <iostream>

void reset(int* p) {
    if (p != nullptr) {
        *p = 0;
    }
}

int main(){
    int a = 5;
    reset(&a);    // 改成 0
    std::cout << "a = " << a << std::endl;
    reset(nullptr); // 不操作
    return 0;
}
```

<img width="448" height="36" alt="image" src="https://github.com/user-attachments/assets/d36abcea-e79d-49cf-bfe5-1925ffb61a14" />

**什么是空值？这不应该传递一个指针吗？**

是的，其实这个‘空值’就是一个特殊的指针，不过它不指向任何有效对象。

**啥是有效对象？难道这个指针指向的地址全是000的空白地址吗？**

简单来说，空指针不指向任何一块真实存在的内存区域，它只是一个特殊的地址值，保证永远不会与任何有效对象的地址相同。有效地址是指程序当前有权限访问的内存区域的地址。现在的操作系统中每个进程都运行在一个独立的虚拟地址空间中，其中分为用户空间和内核空间，用户空间是程序的代码和数据，内核空间所有程序共享映射到同一个空间。CPU在运行的时候也分为**用户态**和**内核态**。执行程序时CPU大多数时间在用户态，当程序中出现调用系统函数的时候(比如`mmap()`)，CPU会切换到内核态，在内核空间执行完命令后回到用户态。为什么这些操作需要在内核态运行呢？因为每个进程只能看到自己的**虚拟地址空间**，没法看到之外的内存状况，而内核可以看到全部的地址状态（毕竟进程的虚拟地址空间也是内核分配的嘛），并为进程分配物理页，在页表中建立新的映射，返回给进程新的虚拟地址，这样才可以访问。

而空指针属于用户空间最低地址的部分，为了保护内核不被攻击，单个进程的用户空间最低的地址：0x00000000处，**虚拟地址没有与物理地址相互映射**，调用空指针会出现程序异常终止（段错误等）。

指针传参可以传递空指针，在系统调用、库函数中，有的函数会把空指针当作输出传递出来。我们可以通过指针传参在我们的函数中判断是否是空指针，让程序更加安全~
