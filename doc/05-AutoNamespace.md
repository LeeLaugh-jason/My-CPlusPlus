# 作用域、命名空间和auto

### 作用域

啥是作用域？作用域是指变量或函数能被访问的范围。我们之前在内存管理中讲到过，
当我们在定义函数和变量的时候（不是静态或者全局）时候，代码会在栈区为每一个函数分配一个帧栈。
在函数内定义的变量会在随着函数的结束，帧栈的释放一同释放

因此对于这一类函数，在其中定义的变量就只存在于被调用的函数中。

这种在函数内定义，随函数销毁而销毁的变量的作用域，叫做 __局部作用域__

在我们写代码的时候常常用到for，while等循环：

```
for(i=1;i<0;i++){
    int j=0;
    
}
```

这些循环语句内部的内容通常用一个花括号括起来。

我们在花括号内定义的内容无法在花括号外调用：

```
void Func1(){
    int i = 0;
    for(i=0; i<10; i++){
        int j = i * 2;
    }
    printf("j=%d\n", j); // 错误，j的作用域仅在for循环内
}
```

<img width="1408" height="178" alt="image" src="https://github.com/user-attachments/assets/b9800257-3170-4350-93cc-2e3e8f53b861" />

报错说j没有定义在这个范围。这种用花括号{}括起来的变量，作用域在花括号内，叫做 **块作用域**

如果我们在花括号内外都定义了同一个变量呢？

```
int x = 100; // 全局变量

void Func2(){
    int x = 10;
{
    int x = 50; // 块作用域变量
    std::cout << "块作用域变量x: " << x << std::endl; // 输出50
    std::cout << "局部变量x: " << ::x << std::endl; // 输出100
    std::cout << "全局变量x: " << ::x << std::endl; // 输出100
}
    std::cout << "局部变量x: " << x << std::endl; // 输出10
    std::cout << "全局变量x: " << ::x << std::endl; // 输出100
}
```

<img width="978" height="204" alt="image" src="https://github.com/user-attachments/assets/7799ffb4-a14b-484c-ae7c-dc6f92b3b6a8" />

从运行结果看出：花括号更里面的变量可以隐藏比它外层的同名变量。但是使用`::`可以在各个块中打印全局变量。

如果想要在块中打印局部变量呢？可以尝试使用引用变量。

```
int x = 100; // 全局变量

void Func2(){
    int x = 10;
    int& ref = x;
{
    int x = 50; // 块作用域变量
    std::cout << "块作用域变量x: " << x << std::endl; // 输出50
    std::cout << "局部变量x: " << ref << std::endl; // 输出10
    std::cout << "全局变量x: " << ::x << std::endl; // 输出100
}
    std::cout << "局部变量x: " << x << std::endl; // 输出10
    std::cout << "全局变量x: " << ::x << std::endl; // 输出100
}
```

<img width="960" height="208" alt="image" src="https://github.com/user-attachments/assets/3c2aa2d8-d861-4605-aa44-256fe5c21343" />

通过引用让变量以别名进入根深的块中。

定义在函数外的变量作用域是 **全局作用域**，定义在类中的变量在 **类作用域**

在底层内存中，作用域是如何运行的呢？

首先，作用域不是在运行时才被排列出来的，而是在编译时就被确定下来了。

在编译时，编译器会维护一个 **符号表**，这个表用于记录：

* 每个变量的名字；
* 它所在的作用域层级；
* 它在内存（栈）中的偏移位置；
* 类型信息等。
