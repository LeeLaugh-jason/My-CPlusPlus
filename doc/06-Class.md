# 定义类、成员函数、成员变量

经过前面的铺垫，我们终于来到了类的领域，开启C++最具特色的类型 **类**

### 类的定义与使用

类是什么？

类是你自定义的数据类型，可以将类看作：数据+行为；

你可以把它看作有一个个功能的模块，类似于一个个cpp文件。

那我们如何定义一个类呢？

```
class Student {
public:               // 访问权限（public: 意味着外部可以访问）
    // 成员变量：描述学生的“属性”
    std::string name;
    int age;

    // 成员函数：描述学生能“做的事”
    void introduce() {
        std::cout << "我是 " << name << "，今年 " << age << " 岁。" << std::endl;
    }
};
```

使用class作为类型定义一个`Student`类，在里面可以定义成员变量、成员函数。

可以把成员变量看作类的一个个属性，而成员函数看成这个类能做到的事。

那我们如何使用这个类呢？

```
int main() {
    Student s;      // 创建一个对象 s，类型是 Student
    s.name = "李笑";  // 访问成员变量
    s.age = 20;

    s.introduce();  // 调用成员函数
    return 0;
}
```

使用我们定义好的`Student`的类的名称创建一个对象，使用`对象.成员变量`和`对象.成员函数`的方式调用对象中的内容。

这部分还挺好理解的，不过深入到底层，我们在使用class定义一个类的时候，这个类会在内存中保存一些什么呢？

首先分为定义类型时和创建对象时：

#### 定义类型时

首先编译器编译到此处，会在“类型系统”中，注册一个类型，这个类型在系统中记录它对应的成员变量和成员函数的结构布局，但 **不分配内存**

结构布局示意图：

```
name → std::string
age  → int
```

#### 调用类型时

当编译器发现在定义一个类的对象时：

```
Student s;
```

编译器会对它的成员变量分配内存，而不会为成员函数分配内存。

why？首先我们知道变量都是存储在堆、栈和全局/静态区中的，而代码都保存在代码区，因此成员函数的代码都保存在代码区防止被修改。

而类的对象可以创建在堆和栈中。

普通的调用放在栈中：

```
Student s;
```

这个`s`的成员变量被整体打包放在帧中，具体一点：创建类的对象时会在栈中分配对象的栈帧，成员变量被存放在这个栈帧中。

使用new时，编译器就在堆中为对象分配空间：

```
Student* p = new Student();  //new返回一个指针
```

我们可以在类中定义静态变量：

```
class Example {
public:
    static int count;
};
int Example::count = 0;
```

静态变量属于所有该类的对象，被保存在全局区/静态区。

### 类的拓展

```
s.introduce();
```

实际上我们在调用类的成员函数的时候，编译器把它偷偷翻译为如下的代码：

```
Student::introduce(&s);
```

也就是说，我们创建的对象的成员函数有一个隐藏指针变量`this`，我们实际调用的是这个指针指向的对象：

```
void introduce(Student* this);
```

于是函数内部的变量：`name`，实际是上是`this->name`。
