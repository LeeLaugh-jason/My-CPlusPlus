# 多态和虚函数表

多态是什么？这是C++面向对象编程的特性之一，我们可以在c++中使用同一个API或者名称指定不同的功能。
比如说：函数模板，函数重载。而在这里我们会介绍在类中的多态：用虚函数和基类指针实现。

我们在上一章讲到了继承，即派生类可以基于基类创建和拓展功能。
而对于基类已有的功能部分，也许只是基于基类定义了一个框架，如果我们想要针对于派生类特异性地修改基类中的功能，就要使用到虚函数。

```
#include <iostream>
#include <string>

class Animal{
    private:
        std::string type;
    public:
        virtual void speak(){
            std::cout << "Animal speaks" << std::endl;
        }
};

class Dog  : public Animal{
    private:
        std::string breed;
    public:
        void speak() override {
            std::cout << "Dog barks" << std::endl;
        }
};

int main(){
    Animal* animalPtr = new Dog();
    animalPtr->speak();  // 输出: Dog barks

    delete animalPtr;
    return 0;
}
```

在基类中定义speak函数前，加上了virtual这一个标识符，代表这个函数是**虚函数**。这样在创建派生类时，可以直接修改这个函数，
建议在函数定义的括号后添加override标识符，让编译器知道这里在修改的是基类的虚函数。

细心的你发现我们在main函数中使用了指针指向这个派生类，而这个指针却是代表基类的指针。为什么可以这样使用呢？

其实在创建派生类的时候，内存分布是从基类到派生类的：

```
内存分布：
基类功能-->派生类功能
|
基类指针
```

如果一个派生类是基于多个基类创建的，那么基类指针指向的就是派生类基于的第一个基类地址。

如果想在基类中创建一个功能待实现的函数，只是留一个API接口但是没有功能，可以这样定义：

```
virtual void spark() = 0; // 纯虚函数
```

这样的函数也叫**纯虚函数**。具有纯虚函数的类是无法创建一个对象的。用我们的代码举例，
要听到这个动物的叫声，我们得知道这个对象它具体是什么动物，如果我们都不知道这是什么动物，我们自然也就得不到对应的叫声。

既然我们使用了virtual这个关键字指定了虚函数，那么编译器如何在后续创建对象的时候知道这个函数是虚函数呢？编译器使用了**虚函数表**(vtable)的工具。
类在被创建后，编译器会自动检测类中的虚函数，并把虚函数的地址整理为一个虚函数表。在类被创建为一个对象后，编译器就会在对象的开头处创建一个**虚函数指针**(vptr)，
指向该类的虚函数表。

有点绕绕的，我们要知道，虚函数表是属于类的，同一个类的每个对象指向同一张虚函数表。这张虚函数表中存放着类中虚函数的索引。

通过`animalPtr->speak();`这个代码聊聊虚函数表的工作流程：

编译时：
1. 编译器查看animalPtr的静态类型是Animal*，指向Dog类的对象
2. 编译器去到Animal类中查看speak这个函数是否为 虚函数
3. 发现是虚函数，生成对应的虚函数表

运行时：
1. 程序执行到animalPtr->speak()这一行，animalPtr指向Dog对象
2. 读取Dog对象的虚函数指针，指向Dog类的虚函数表
3. 程序查找speak函数的序列，发现了对应的函数地址
4. 程序调用这个地址的函数

