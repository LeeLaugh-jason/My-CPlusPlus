# 智能指针

### 什么是智能指针？

智能指针是在C++11后提出的自动管理动态内存的一种**类模板**，也就是我们存放在堆中的数据。

我们在使用堆中的数据时，需要先自己`new`一块内存获得指针，当这块内存不用的时候我们就可以把它释放`delete`。

为了防止遗忘释放内存或者重复释放内存，我们可以使用智能指针来管理我们的动态内存。

它实际上是基于RAII（Resource Acquisition Is Initialization）机制实现，自动实现内存的开辟与析构。

在C++中有不同的封装好的智能指针模板，我们来一个个学学：

### std::unique_ptr

它的特点是，一个资源只能被一个指针独占。也就是：同一个对象只能由一个unique_ptr指向它。

这里的对象就是指我们在堆中开辟的内存空间。

我们从用法看看这个指针的用法：

```
#include <memory>

std::unique_ptr<int> p = std::make_unique<int>(10);
```

我们可以有多种方式开辟内存空间。当然可以使用new()来开辟空间，也可以使用reset进行创建新对象。不过这样都不如使用`make_unique`安全。

这回涉及到一些抛出异常的问题，我们在后续再学习。

总之在这里，记住使用make_unique开辟内存就行。

然后使用`unique_ptr`来管理得到的`p`这个对象。这个对象中存储着指向这块内存的裸指针。

```
*p = 20;
std::cout << *p << std::endl;
```

我们可以直接对这个对象解引用，在这个对象内实际上重载了解引用和成员访问符

注意`unique_ptr`是不可以复制的，它需要确保只有他一个人占据这块内存。

不过可以使用`move`函数将这个对象的所有权转移给另一个人。

```
std::unique_ptr<int> anotherPtr = std::move(smartPtr);
```

### std::shared_ptr

相比于unique，shared支持多个对象那个智能指针指向同一块堆中的内存。在`shared_ptr`中会在裸指针的基础上多一个指针，一个指向控制块的指针。

这个控制块中
