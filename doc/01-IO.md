### 第一个程序
同所有编程语言的学习一样，第一个任务就是编写C++程序，使用GCC编译器将C++源码编译为机器码（可执行文件）。这里我们学习第一个C++的特性，输入输出流。
在C++中主要的流类型有：标准流对象、文件流、字符串流。
#### 标准流对象
什么是标准流？是直接与输入输出设备相关联的流对象，四种标准流对象是：
```
cin -标准输入流（有缓冲）
cout -标准输出流（有缓冲）
cerr -标准错误流（无缓冲）
clog -标准日志流（有缓冲）
```
在这里介绍一下缓冲机制。什么是缓冲？打个比方，我们写了一个这样的程序：
```
//C语言
#include <stdio.h>
int main(){
	int i, j;
	scanf("iIN=%d, jIN=%d", &i, &j);
	printf("iOUT=%d jOUT=%d\n",i ,j);
	return 0;
}
```
这是一个简单的C语言代码，在终端输入的数字被程序打印到终端中。在这里我们思考，我们的输入是如何被终端识别到作为`i`的值的？
肯定不是我刚输入这个数`i`这个值就变成了我输入的部分，一定是我触发了什么条件，我输入的字符串才被scanf识别到的。
是的，我按下了enter，按下enter之前，我的数据都存储在终端缓冲区，按下enter后，数据从终端缓冲区转移到了stdin缓冲区里面，等待被scanf等函数读取。不过scanf函数只会读取匹配的字符，不匹配的部分会被留在缓冲区（大部分时候会把`\n`留在缓冲区，因此需要用`getchar`清除缓冲区）。
这是C语言的缓冲机制，而C++的缓冲机制和C语言有些不同。我们在后续使用过程中再讲起。
现在编写我们的第一个C++程序，输出：`HelloWorld`
```
#include <iostream>

int main() {
    std::cout << "Hello, Stream!" << std::endl;
    return 0;
}
```
<img width="453" height="32" alt="image" src="https://github.com/user-attachments/assets/a87d8798-c3d2-4ff7-94a9-a9d1c6c75f45" />

终端就可以看到输出了~

刚刚讲到缓冲机制，在上面的代码中我们在`“Hello Stream!”`后添加了std::endl，它的作用等同于输出一个换行符`'\n'`，同时刷新输出缓存区等同于`cout.flush()`。在我们使用std::cout << "Hello Stream!"时，程序将这个字符串暂时存放在了内存中，而没有真正输出到屏幕上，我们用一个程序解释：

```
#include <iostream>

int main() {
    std::cout << "Hello, Stream!" ;
    while( true ) {}    
    return 0;
}
```

这里我去掉了`std::endl`，同时在cout后加上了死循环，发现终端中没有任何的输出显示。

<img width="454" height="36" alt="image" src="https://github.com/user-attachments/assets/602b4336-3f97-4af4-8997-273ced6758d8" />

因为这个字符串还被保留在输出缓冲区。C++的缓冲区是由两个缓冲层组成的：iostream层和libc层，分别对应C++的std::ostream和C语言的stdout。默认情况下这两层缓冲区是‘同步’的，也就是说我在C++源代码中使用`flush()`之后两层缓冲区会同时刷新。

不过也有让这两层缓冲区不同步的方式，使用`std::ios::sync_with_stdio(false);`这一段代码可以将两层缓冲区分隔开，成为两条独立的输出通道，每一层缓冲区独自刷新自己的缓冲区，需要在stdout层刷新缓冲的时候需要用`std::fflush(stdout);`这段代码。

输出层类似，我们在终端中输入文字和字符，会首先从内核输入缓冲区进入到cin的`streambuf`，在执行cin这个代码时解析器首先检查缓冲区中是否有数字，如果有未读取的字符就直接读取，如果缓冲区空了就调用`underflow()`进而调用底层read经内核输入缓冲区的数据拷贝到C++中的缓冲区`streambuf`。

```
#include <iostream>

int main() {
    int x;
    std::cin >> x;
    std::cout << "Hello, Stream! You entered: " << x << std::endl;
    
    return 0;
}
```

如果要清空输入缓冲区，就是将里面的内容读出来丢掉即可。参考：`std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');`
